






<!doctype html>
<html lang="zh-CN">
<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="author" content="satan">
  
  
  
  
    <meta name="description" content="环境安装好之后，让我们来建立一个小的flask应用
#一个最小的应用¶代码如下：12345678910111213from flask import Flaskapp = Flask(__name__)@app.route(&apos;/&apos;)def hello_world():    return &apos;Hello World!&apos;    @app.route(&ap...">
  
  <title>flask学习（四--第一个小应用） [ shiny-boy ]</title>
  
    <link rel="alternate" href="/atom.xml" title="shiny-boy">
  
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  
  <link rel="stylesheet" href="/css/random.css">
<link rel="stylesheet" href="/css/vegas.min.css">
<link rel="stylesheet" href="/css/highlight-railscasts.css">
<link rel="stylesheet" href="/css/jquery.fancybox.css">
<link rel="stylesheet" href="/css/iconfont/iconfont.css">
<link rel="stylesheet" href="/css/jquery.fancybox-thumbs.css">
<link rel="stylesheet" href="/css/plyr.css">
  
</head>

<body>
<div class="side-navigate hide-area">
  
    <div class="item prev">
      <a href="/2017/03/07/flask入门(1)/">
        <div class="item-icon"></div>
      </a>
      <div class="item-title">
        初识flask（一）
      </div>
    </div>
  
  
    <div class="item next">
      <a href="/2017/03/07/flask学习（二）/">
        <div class="item-icon"></div>
      </a>
      <div class="item-title">
        flask学习（二）
      </div>
    </div>
  
</div>
<div id="outer-container" class="hide-area">
<div id="container">
  <div id="menu-outer" class="slide-down">
    <div id="menu-inner">
      <div id="brand">
        
        <a onClick="openUserCard()">
          <img id="avatar" src="http://photo.yupoo.com/lujunyuan/BLsD9Vlx/medish.jpg"/>
          <div id="homelink">shiny-boy</div>
        </a>
      </div>
      <div id="menu-list">
        <ul>
        
        
          
            <li>
          
            <a href="/index.html">Home</a>
            
          </li>
        
          
            <li>
          
            <a href="/archives">Archives</a>
            
          </li>
        
          
            <li>
          
            <a href="/tags">Tags</a>
            
          </li>
        
          
            <li>
          
            <a href="/categories">Categories</a>
            
          </li>
        
          
            <li>
          
            <a href="/about">About</a>
            
          </li>
        
          
            <li>
          
            <a href="https://github.com/aiwanxia/aiwanxia.github.io">Github</a>
            
          </li>
        
        </ul>
      </div>
      <div id="show-menu">
        <button>Menu</button>
      </div>
    </div>
  </div>

  <div id="content-outer">
    <div id="content-inner">
      
      
  <article id="post">
    <h1>flask学习（四--第一个小应用）</h1>
    <p class="page-title-sub">
      <span id = "post-title-date">撰写于 2017-03-07</span>
      
        <span id = "post-title-updated">修改于 2017-03-08</span>
      
      
      
      <span id = "post-title-tags">
      标签
      
      
        
        
        <a href="/tags/python/">python</a>
      
      </span>
      
    </p>
    
    <p>环境安装好之后，让我们来建立一个小的flask应用</p>
<p>#<strong>一个最小的应用¶</strong><br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">from flask import Flask</div><div class="line">app = Flask(__name__)</div><div class="line"></div><div class="line">@app.route(&apos;/&apos;)</div><div class="line">def hello_world():</div><div class="line">    return &apos;Hello World!&apos;</div><div class="line">    </div><div class="line">@app.route(&apos;/user/&lt;name&gt;&apos;)</div><div class="line">    def user(name):</div><div class="line">        return &apos;&lt;h1&gt;Hello, %s!&lt;/h1&gt;&apos; % name</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    app.run(debug = True)</div></pre></td></tr></table></figure></p>
<p>把它保存为 hello.py （或是类似的），然后用 Python 解释器来运行。 确保你的应用文件名不是 flask.py ，因为这将与 Flask 本身冲突。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ python hello.py</div><div class="line"> * Running on http://127.0.0.1:5000/</div></pre></td></tr></table></figure></p>
<p>运行之后，打开<a href="http://127.0.0.1:5000（/user/username）" target="_blank" rel="external">http://127.0.0.1:5000（/user/username）</a></p>
<p>那么，这段代码做了什么？</p>
<p>首先，我们导入了 <code>Flask</code> 类。这个类的实例将会是我们的 WSGI 应用程序。<br>接下来，我们创建一个该类的实例，第一个参数是应用模块或者包的名称。 如果你使用单一的模块（如本例），你应该使用 <code>__name__</code> ，因为模块的名称将会因其作为单独应用启动还是作为模块导入而有不同（ 也即是 <code>&#39;__main__&#39;</code> 或实际的导入名）。这是必须的，这样 Flask 才知道到哪去找模板、静态文件等等。详情见 Flask 的文档。<br>然后，我们使用 <code>route() 装饰器</code>告诉 Flask 什么样的URL 能触发我们的函数。<br>这个函数的名字也在生成 URL 时被特定的函数采用，这个函数返回我们想要显示在用户浏览器中的信息。<br>最后我们用 run() 函数来让应用运行在本地服务器上。 其中 <code>if __name__ == &#39;__main__&#39;:</code> 确保服务器只会在该脚本被 Python 解释器直接执行的时候才会运行，而不是作为模块导入的时候。<br>欲关闭服务器，按 Ctrl+C。</p>
<p>外部可访问的服务器<br>如果你运行了这个服务器，你会发现它只能从你自己的计算机上访问，网络中其它任何的地方都不能访问。在调试模式下，用户可以在你的计算机上执行任意 Python 代码。因此，这个行为是默认的。</p>
<p>如果你禁用了 debug 或信任你所在网络的用户，你可以简单修改调用 run() 的方法使你的服务器公开可用，如下:</p>
<p>app.run(host=’0.0.0.0’)<br>这会让操作系统监听所有公网 IP。</p>
<p>#调试模式<br>虽然 run() 方法适用于启动本地的开发服务器，但是你每次修改代码后都要手动重启它。这样并不够优雅，而且 Flask 可以做到更好。如果你启用了调试支持，服务器会在代码修改后自动重新载入，并在发生错误时提供一个相当有用的调试器。</p>
<p>有两种途径来启用调试模式。一种是直接在应用对象上设置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">app.debug = True</div><div class="line">app.run()</div></pre></td></tr></table></figure></p>
<p>另一种是作为 run 方法的一个参数传入:</p>
<p><code>app.run(debug=True)</code>(这种简洁点)<br>两种方法的效果完全相同。</p>
<p>注意#<br>尽管交互式调试器在允许 fork 的环境中无法正常使用（也即在生产服务器上正常使用几乎是不可能的），但它依然允许执行任意代码。这使它成为一个巨大的安全隐患，因此它 绝对不能用于生产环境 。</p>
<p>#路由<br>现代 <code>Web</code> 应用的 <code>URL</code> 十分优雅，易于人们辨识记忆，这一点对于那些面向使用低速网络连接移动设备访问的应用特别有用。如果可以不访问索引页，而是直接访问想要的那个页面，他们多半会笑逐颜开而再度光顾。</p>
<p>如上所见， <code>route() 装饰器</code>把一个函数绑定到对应的 URL 上。</p>
<p>这里是一些基本的例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@app.route(&apos;/&apos;)</div><div class="line">def index():</div><div class="line">    return &apos;Index Page&apos;</div><div class="line"></div><div class="line">@app.route(&apos;/hello&apos;)</div><div class="line">def hello():</div><div class="line">    return &apos;Hello World&apos;</div></pre></td></tr></table></figure></p>
<p>但是，不仅如此！你可以构造含有动态部分的 URL，也可以在一个函数上附着多个规则。</p>
<p>#变量规则<br>要给 URL 添加变量部分，你可以把这些特殊的字段标记为 <variable_name> ， 这个部分将会作为命名参数传递到你的函数。规则可以用 <converter:variable_name> 指定一个可选的转换器。这里有一些不错的例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@app.route(&apos;/user/&lt;username&gt;&apos;)</div><div class="line">def show_user_profile(username):</div><div class="line">    # show the user profile for that user</div><div class="line">    return &apos;User %s&apos; % username</div><div class="line"></div><div class="line">@app.route(&apos;/post/&lt;int:post_id&gt;&apos;)</div><div class="line">def show_post(post_id):</div><div class="line">    # show the post with the given id, the id is an integer</div><div class="line">    return &apos;Post %d&apos; % post_id</div></pre></td></tr></table></figure></converter:variable_name></variable_name></p>
<p>#唯一 URL / 重定向行为<br>Flask 的 URL 规则基于 Werkzeug 的路由模块。这个模块背后的思想是基于 Apache 以及更早的 HTTP 服务器主张的先例，保证优雅且唯一的 URL。</p>
<p>以这两个规则为例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@app.route(&apos;/projects/&apos;)</div><div class="line">def projects():</div><div class="line">    return &apos;The project page&apos;</div><div class="line"></div><div class="line">@app.route(&apos;/about&apos;)</div><div class="line">def about():</div><div class="line">    return &apos;The about page&apos;</div></pre></td></tr></table></figure></p>
<p>虽然它们看起来着实相似，但它们结尾斜线的使用在 URL 定义 中不同。 <code>第一种情况中，指向 projects 的规范 URL 尾端有一个斜线</code>。这种感觉很像在文件系统中的文件夹<code>。访问一个结尾不带斜线的 URL 会被 Flask 重定向到带斜线的规范 URL 去。</code></p>
<p>然而，<code>第二种情况的 URL 结尾不带斜线</code>，类似 UNIX-like 系统下的文件的路径名。<code>访问结尾带斜线的 URL 会产生一个 404 “Not Found” 错误。</code></p>
<p>这个行为使得在遗忘尾斜线时，允许关联的 URL 接任工作，与 Apache 和其它的服务器的行为并无二异。此外，也保证了 URL 的唯一，有助于避免搜索引擎索引同一个页面两次。</p>
<p>#构造 URL<br><code>如果 Flask 能匹配 URL，那么 Flask 可以生成它们吗？</code>当然可以。你可以用 <code>url_for()</code> 来给指定的函数构造 URL。它接受函数名作为第一个参数，也接受对应 URL 规则的变量部分的命名参数。未知变量部分会添加到 URL 末尾作为查询参数。这里有一些例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from flask import Flask, url_for</div><div class="line">&gt;&gt;&gt; app = Flask(__name__)</div><div class="line">&gt;&gt;&gt; @app.route(&apos;/&apos;)</div><div class="line">... def index(): pass</div><div class="line">...</div><div class="line">&gt;&gt;&gt; @app.route(&apos;/login&apos;)</div><div class="line">... def login(): pass</div><div class="line">...</div><div class="line">&gt;&gt;&gt; @app.route(&apos;/user/&lt;username&gt;&apos;)</div><div class="line">... def profile(username): pass</div><div class="line">...</div><div class="line">&gt;&gt;&gt; with app.test_request_context():</div><div class="line">...  print url_for(&apos;index&apos;)</div><div class="line">...  print url_for(&apos;login&apos;)</div><div class="line">...  print url_for(&apos;login&apos;, next=&apos;/&apos;)</div><div class="line">...  print url_for(&apos;profile&apos;, username=&apos;John Doe&apos;)</div><div class="line">...</div><div class="line">/</div><div class="line">/login</div><div class="line">/login?next=/</div><div class="line">/user/John%20Doe</div></pre></td></tr></table></figure></p>
<p>（这里也用到了 <code>test_request_context()</code> 方法，下面会解释。即使我们正在通过 Python 的 shell 进行交互，它依然会告诉 Flask 要表现为正在处理一个请求。请看下面的解释。 环境局部变量 ）</p>
<p>为什么你要构建 URL 而非在模板中硬编码？这里有三个绝妙的理由：</p>
<p>反向构建通常比硬编码的描述性更好。更重要的是，它允许你一次性修改 URL， 而不是到处边找边改。<br>URL 构建会转义特殊字符和 Unicode 数据，免去你很多麻烦。<br>如果你的应用不位于 URL 的根路径（比如，在 /myapplication 下，而不是 / ）， url_for() 会妥善处理这个问题</p>
<p>#HTTP 方法<br>HTTP （与 Web 应用会话的协议）有许多不同的访问 URL 方法。默认情况下，路由只回应 GET 请求，但是通过 route() 装饰器传递 methods 参数可以改变这个行为。这里有一些例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@app.route(&apos;/login&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])</div><div class="line">def login():</div><div class="line">    if request.method == &apos;POST&apos;:</div><div class="line">        do_the_login()</div><div class="line">    else:</div><div class="line">        show_the_login_form()</div></pre></td></tr></table></figure></p>
<p>如果存在 GET ，那么也会替你自动地添加 HEAD，无需干预。它会确保遵照 HTTP RFC （描述 HTTP 协议的文档）处理 HEAD 请求，所以你可以完全忽略这部分的 HTTP 规范。同样，自从 Flask 0.6 起， 也实现了 OPTIONS 的自动处理。</p>
<p>你不知道一个 HTTP 方法是什么？不必担心，这里会简要介绍 HTTP 方法和它们为什么重要：</p>
<p>HTTP 方法（也经常被叫做“谓词”）告知服务器，客户端想对请求的页面 做 些什么。下面的都是非常常见的方法：</p>
<p><strong>GET</strong><br>浏览器告知服务器：只 获取 页面上的信息并发给我。这是最常用的方法。<br><strong>HEAD</strong><br>浏览器告诉服务器：欲获取信息，但是只关心 消息头 。应用应像处理 GET 请求一样来处理它，但是不分发实际内容。在 Flask 中你完全无需 人工 干预，底层的 Werkzeug 库已经替你打点好了。<br><strong>POST</strong><br>浏览器告诉服务器：想在 URL 上 发布 新信息。并且，服务器必须确保 数据已存储且仅存储一次。这是 HTML 表单通常发送数据到服务器的方法。<br><strong>PUT</strong><br>类似 POST 但是服务器可能触发了存储过程多次，多次覆盖掉旧值。你可 能会问这有什么用，当然这是有原因的。考虑到传输中连接可能会丢失，在 这种 情况下浏览器和服务器之间的系统可能安全地第二次接收请求，而 不破坏其它东西。因为 POST 它只触发一次，所以用 POST 是不可能的。<br><strong>DELETE</strong><br>删除给定位置的信息。<br><strong>OPTIONS</strong><br>给客户端提供一个敏捷的途径来弄清这个 URL 支持哪些 HTTP 方法。 从 Flask 0.6 开始，实现了自动处理。<br>有趣的是，在 HTML4 和 XHTML1 中，表单只能以 GET 和 POST 方法提交到服务器。但是 JavaScript 和未来的 HTML 标准允许你使用其它所有的方法。此外，HTTP 最近变得相当流行，浏览器不再是唯一的 HTTP 客户端。比如，许多版本控制系统就在使用 HTTP。</p>
<p>#静态文件¶<br>动态 web 应用也会需要静态文件，通常是 CSS 和 JavaScript 文件。理想状况下， 你已经配置好 Web 服务器来提供静态文件，但是在开发中，Flask 也可以做到。 只要在你的包中或是模块的所在目录中创建一个名为 static 的文件夹，在应用中使用 /static 即可访问。</p>
<p>给静态文件生成 URL ，使用特殊的 ‘static’ 端点名:</p>
<p><code>url_for(&#39;static&#39;, filename=&#39;style.css&#39;)</code></p>
<p>这个文件应该存储在文件系统上的 static/style.css 。</p>
<p>#模板渲染<br>用 Python 生成 HTML 十分无趣，而且相当繁琐，因为你必须手动对 HTML 做转义来保证应用的安全。为此，Flask 配备了 Jinja2 模板引擎。</p>
<p>你可以使用 <code>render_template()</code> 方法来渲染模板。你需要做的一切就是将模板名和你想作为关键字的参数传入模板的变量。这里有一个展示如何渲染模板的简例:</p>
<p><code>from flask import render_template</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@app.route(&apos;/hello/&apos;)</div><div class="line">@app.route(&apos;/hello/&lt;name&gt;&apos;)</div><div class="line">def hello(name=None):</div><div class="line">    return render_template(&apos;hello.html&apos;, name=name)</div></pre></td></tr></table></figure></p>
<p>Flask 会在 templates 文件夹里寻找模板。所以，如果你的应用是个模块，这个文件夹应该与模块同级；如果它是一个包，那么这个文件夹作为包的子目录:</p>
<p>情况 1: 模块:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/application.py</div><div class="line">/templates</div><div class="line">/hello.html</div></pre></td></tr></table></figure></p>
<p>情况 2: 包:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/application</div><div class="line">    /__init__.py</div><div class="line">    /templates</div><div class="line">        /hello.html</div></pre></td></tr></table></figure></p>
<p>关于模板，你可以发挥 Jinja2 模板的全部实例。更多信息请见 Jinja2 模板文档 。</p>
<p>这里有一个模板实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;!doctype html&gt;</div><div class="line">&lt;title&gt;Hello from Flask&lt;/title&gt;</div><div class="line">&#123;% if name %&#125;</div><div class="line">  &lt;h1&gt;Hello &#123;&#123; name &#125;&#125;!&lt;/h1&gt;</div><div class="line">&#123;% else %&#125;</div><div class="line">  &lt;h1&gt;Hello World!&lt;/h1&gt;</div><div class="line">&#123;% endif %&#125;</div></pre></td></tr></table></figure></p>
<p>在模板里，你也可以访问 request 、 session 和 g [1] 对象， 以及 get_flashed_messages() 函数。</p>
<p>模板继承让模板用起来相当顺手。如欲了解继承的工作机理，请跳转到 模板继承 模式的文档。最起码，模板继承能使特定元素 （比如页眉、导航栏和页脚）可以出现在所有的页面。</p>
<p>自动转义功能默认是开启的，所以如果 name 包含 HTML ，它将会被自动转义。如果你能信任一个变量，并且你知道它是安全的（例如一个模块把 Wiki 标记转换为 HTML），你可以用 Markup 类或 |safe 过滤器在模板中把它标记为安全的。在 Jinja 2 文档中，你会看到更多的例子。</p>
<p>这里是一个 Markup 类如何使用的简单介绍:<br>?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from flask import Markup</div><div class="line">&gt;&gt;&gt; Markup(&apos;&lt;strong&gt;Hello %s!&lt;/strong&gt;&apos;) % &apos;&lt;blink&gt;hacker&lt;/blink&gt;&apos;</div><div class="line">Markup(u&apos;&lt;strong&gt;Hello &amp;lt;blink&amp;gt;hacker&amp;lt;/blink&amp;gt;!&lt;/strong&gt;&apos;)</div><div class="line">&gt;&gt;&gt; Markup.escape(&apos;&lt;blink&gt;hacker&lt;/blink&gt;&apos;)</div><div class="line">Markup(u&apos;&amp;lt;blink&amp;gt;hacker&amp;lt;/blink&amp;gt;&apos;)</div><div class="line">&gt;&gt;&gt; Markup(&apos;&lt;em&gt;Marked up&lt;/em&gt; &amp;raquo; HTML&apos;).striptags()</div><div class="line">u&apos;Marked up \xbb HTML&apos;</div><div class="line">在 0.5 版更改: 自动转义不再在所有模板中启用。下列扩展名的模板会触发自动转义： .html 、 .htm 、.xml 、 .xhtml 。从字符串加载的模板会禁用自动转义。</div></pre></td></tr></table></figure></p>
<p>?<br>[1]    不确定 g 对象是什么？它允许你按需存储信息， 查看（ g ）对象的文档和 在 Flask 中使用 SQLite 3 的文档以获取更多信息。<br>访问请求数据<br>对于 Web 应用，与客户端发送给服务器的数据交互至关重要。在 Flask 中由全局的 request 对象来提供这些信息。如果你有一定的 Python 经验，你会好奇，为什么这个对象是全局的，为什么 Flask 还能保证线程安全。答案是环境作用域：</p>
<p>#环境局部变量<br>内幕<br>如果你想理解其工作机制及如何利用环境局部变量实现自动化测试，请阅读此节，否则可跳过。<br>Flask 中的某些对象是全局对象，但却不是通常的那种。这些对象实际上是特定环境的局部对象的代理。虽然很拗口，但实际上很容易理解。</p>
<p>想象一下处理线程的环境。一个请求传入，Web 服务器决定生成一个新线程（ 或者别的什么东西，只要这个底层的对象可以胜任并发系统，而不仅仅是线程）。 当 Flask 开始它内部的请求处理时，它认定当前线程是活动的环境，并绑定当前的应用和 WSGI 环境到那个环境上（线程）。它的实现很巧妙，能保证一个应用调用另一个应用时不会出现问题。</p>
<p>所以，这对你来说意味着什么？除非你要做类似单元测试的东西，否则你基本上可以完全无视它。你会发现依赖于一段请求对象的代码，因没有请求对象无法正常运行。解决方案是，自行创建一个请求对象并且把它绑定到环境中。单元测试的最简单的解决方案是：用 test_request_context() 环境管理器。结合 with 声明，绑定一个测试请求，这样你才能与之交互。下面是一个例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">from flask import request</div><div class="line"></div><div class="line">with app.test_request_context(&apos;/hello&apos;, method=&apos;POST&apos;):</div><div class="line">    # now you can do something with the request until the</div><div class="line">    # end of the with block, such as basic assertions:</div><div class="line">    assert request.path == &apos;/hello&apos;</div><div class="line">    assert request.method == &apos;POST&apos;</div></pre></td></tr></table></figure></p>
<p>另一种可能是：传递整个 WSGI 环境给 request_context() 方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from flask import request</div><div class="line"></div><div class="line">with app.request_context(environ):</div><div class="line">    assert request.method == &apos;POST&apos;</div></pre></td></tr></table></figure></p>
<p>请求对象<br>API 章节对请求对象作了详尽阐述（参见 request ），因此这里不会赘述。此处宽泛介绍一些最常用的操作。首先从 flask 模块里导入它:</p>
<p><code>from flask import request</code></p>
<p>当前请求的 HTTP 方法可通过 method 属性来访问。通过:attr:~flask.request.form 属性来访问表单数据（ POST 或 PUT 请求提交的数据）。这里有一个用到上面提到的那两个属性的完整实例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@app.route(&apos;/login&apos;, methods=[&apos;POST&apos;, &apos;GET&apos;])</div><div class="line">def login():</div><div class="line">    error = None</div><div class="line">    if request.method == &apos;POST&apos;:</div><div class="line">        if valid_login(request.form[&apos;username&apos;],</div><div class="line">                       request.form[&apos;password&apos;]):</div><div class="line">            return log_the_user_in(request.form[&apos;username&apos;])</div><div class="line">        else:</div><div class="line">            error = &apos;Invalid username/password&apos;</div><div class="line">    # the code below is executed if the request method</div><div class="line">    # was GET or the credentials were invalid</div><div class="line">    return render_template(&apos;login.html&apos;, error=error)</div></pre></td></tr></table></figure></p>
<p>当访问 form 属性中的不存在的键会发生什么？会抛出一个特殊的 KeyError 异常。你可以像捕获标准的 KeyError 一样来捕获它。 如果你不这么做，它会显示一个 <code>HTTP 400 Bad Request</code> 错误页面。所以，多数情况下你并不需要干预这个行为。</p>
<p>你可以通过 args 属性来访问 URL 中提交的参数 （ ?key=value ）:</p>
<p><code>searchword = request.args.get(&#39;q&#39;, &#39;&#39;)</code></p>
<p>我们推荐用 get 来访问 URL 参数或捕获 KeyError ，因为用户可能会修改 URL，向他们展现一个 400 bad request 页面会影响用户体验。</p>
<p>欲获取请求对象的完整方法和属性清单，请参阅 request 的文档。</p>
<p>文件上传<br>用 Flask 处理文件上传很简单。只要确保你没忘记在 HTML 表单中设置 <code>enctype=&quot;multipart/form-data&quot;</code> 属性，不然你的浏览器根本不会发送文件。</p>
<p>已上传的文件存储在内存或是文件系统中一个临时的位置。你可以通过请求对象的 files 属性访问它们。每个上传的文件都会存储在这个字典里。它表现近乎为一个标准的 Python file 对象，但它还有一个 save() 方法，这个方法允许你把文件保存到服务器的文件系统上。这里是一个用它保存文件的例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">from flask import request</div><div class="line"></div><div class="line">@app.route(&apos;/upload&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])</div><div class="line">def upload_file():</div><div class="line">    if request.method == &apos;POST&apos;:</div><div class="line">        f = request.files[&apos;the_file&apos;]</div><div class="line">        f.save(&apos;/var/www/uploads/uploaded_file.txt&apos;)</div><div class="line">    ...</div></pre></td></tr></table></figure></p>
<p>如果你想知道上传前文件在客户端的文件名是什么，你可以访问 filename 属性。但请记住， 永远不要信任这个值，这个值是可以伪造的。如果你要把文件按客户端提供的文件名存储在服务器上，那么请把它传递给 Werkzeug 提供的 secure_filename() 函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">from flask import request</div><div class="line">from werkzeug import secure_filename</div><div class="line"></div><div class="line">@app.route(&apos;/upload&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])</div><div class="line">def upload_file():</div><div class="line">    if request.method == &apos;POST&apos;:</div><div class="line">        f = request.files[&apos;the_file&apos;]</div><div class="line">        f.save(&apos;/var/www/uploads/&apos; + secure_filename(f.filename))</div><div class="line">    ...</div></pre></td></tr></table></figure></p>
<p>一些更好的例子，见 上传文件 模式。</p>
<p>Cookies<br>你可以通过 cookies 属性来访问 Cookies，用响应对象的 set_cookie 方法来设置 Cookies。请求对象的 cookies 属性是一个内容为客户端提交的所有 Cookies 的字典。如果你想使用会话，请不要直接使用 Cookies，请参考 会话 一节。在 Flask 中，已经注意处理了一些 Cookies 安全细节。</p>
<p>读取 cookies:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">from flask import request</div><div class="line"></div><div class="line">@app.route(&apos;/&apos;)</div><div class="line">def index():</div><div class="line">    username = request.cookies.get(&apos;username&apos;)</div><div class="line">    # use cookies.get(key) instead of cookies[key] to not get a</div><div class="line">    # KeyError if the cookie is missing.</div><div class="line">存储 cookies:</div><div class="line"></div><div class="line">from flask import make_response</div><div class="line"></div><div class="line">@app.route(&apos;/&apos;)</div><div class="line">def index():</div><div class="line">    resp = make_response(render_template(...))</div><div class="line">    resp.set_cookie(&apos;username&apos;, &apos;the username&apos;)</div><div class="line">    return resp</div></pre></td></tr></table></figure></p>
<p>可注意到的是，Cookies 是设置在响应对象上的。由于通常视图函数只是返回字符串，之后 Flask 将字符串转换为响应对象。如果你要显式地转换，你可以使用 make_response() 函数然后再进行修改。</p>
<p>有时候你想设置 Cookie，但响应对象不能醋在。这可以利用 延迟请求回调 模式实现。</p>
<p>为此，也可以阅读 关于响应 。</p>
<p>重定向和错误<br>你可以用 redirect() 函数把用户重定向到其它地方。放弃请求并返回错误代码，用 abort() 函数。这里是一个它们如何使用的例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">from flask import abort, redirect, url_for</div><div class="line"></div><div class="line">@app.route(&apos;/&apos;)</div><div class="line">def index():</div><div class="line">    return redirect(url_for(&apos;login&apos;))</div><div class="line"></div><div class="line">@app.route(&apos;/login&apos;)</div><div class="line">def login():</div><div class="line">    abort(401)</div><div class="line">    this_is_never_executed()</div></pre></td></tr></table></figure></p>
<p>这是一个相当无意义的例子因为用户会从主页重定向到一个不能访问的页面 （401 意味着禁止访问），但是它展示了重定向是如何工作的。</p>
<p>默认情况下，错误代码会显示一个黑白的错误页面。如果你要定制错误页面， 可以使用 errorhandler() 装饰器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">from flask import render_template</div><div class="line"></div><div class="line">@app.errorhandler(404)</div><div class="line">def page_not_found(error):</div><div class="line">    return render_template(&apos;page_not_found.html&apos;), 404</div></pre></td></tr></table></figure></p>
<p>注意 render_template() 调用之后的 404 。这告诉 Flask，该页的错误代码是 404 ，即没有找到。默认为 200，也就是一切正常。</p>
<p>关于响应<br>视图函数的返回值会被自动转换为一个响应对象。如果返回值是一个字符串， 它被转换为该字符串为主体的、状态码为 200 OK<code>的 、 MIME 类型是</code>text/html 的响应对象。Flask 把返回值转换为响应对象的逻辑是这样：</p>
<p>如果返回的是一个合法的响应对象，它会从视图直接返回。<br>如果返回的是一个字符串，响应对象会用字符串数据和默认参数创建。<br>如果返回的是一个元组，且元组中的元素可以提供额外的信息。这样的元组必须是 (response, status, headers) 的形式，且至少包含一个元素。 status 值会覆盖状态代码， headers 可以是一个列表或字典，作为额外的消息标头值。<br>如果上述条件均不满足， Flask 会假设返回值是一个合法的 WSGI 应用程序，并转换为一个请求对象。<br>如果你想在视图里操纵上述步骤结果的响应对象，可以使用 make_response() 函数。</p>
<p>譬如你有这样一个视图:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@app.errorhandler(404)</div><div class="line">def not_found(error):</div><div class="line">    return render_template(&apos;error.html&apos;), 404</div><div class="line">你只需要把返回值表达式传递给 make_response() ，获取结果对象并修改，然后再返回它:</div><div class="line"></div><div class="line">@app.errorhandler(404)</div><div class="line">def not_found(error):</div><div class="line">    resp = make_response(render_template(&apos;error.html&apos;), 404)</div><div class="line">    resp.headers[&apos;X-Something&apos;] = &apos;A value&apos;</div><div class="line">    return resp</div></pre></td></tr></table></figure></p>
<p>会话<br>除请求对象之外，还有一个 session 对象。它允许你在不同请求间存储特定用户的信息。它是在 Cookies 的基础上实现的，并且对 Cookies 进行密钥签名。这意味着用户可以查看你 Cookie 的内容，但却不能修改它，除非用户知道签名的密钥。</p>
<p>要使用会话，你需要设置一个密钥。这里介绍会话如何工作:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">from flask import Flask, session, redirect, url_for, escape, request</div><div class="line"></div><div class="line">app = Flask(__name__)</div><div class="line"></div><div class="line">@app.route(&apos;/&apos;)</div><div class="line">def index():</div><div class="line">    if &apos;username&apos; in session:</div><div class="line">        return &apos;Logged in as %s&apos; % escape(session[&apos;username&apos;])</div><div class="line">    return &apos;You are not logged in&apos;</div><div class="line"></div><div class="line">@app.route(&apos;/login&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])</div><div class="line">def login():</div><div class="line">    if request.method == &apos;POST&apos;:</div><div class="line">        session[&apos;username&apos;] = request.form[&apos;username&apos;]</div><div class="line">        return redirect(url_for(&apos;index&apos;))</div><div class="line">    return &apos;&apos;&apos;</div><div class="line">        &lt;form action=&quot;&quot; method=&quot;post&quot;&gt;</div><div class="line">            &lt;p&gt;&lt;input type=text name=username&gt;</div><div class="line">            &lt;p&gt;&lt;input type=submit value=Login&gt;</div><div class="line">        &lt;/form&gt;</div><div class="line">    &apos;&apos;&apos;</div><div class="line"></div><div class="line">@app.route(&apos;/logout&apos;)</div><div class="line">def logout():</div><div class="line">    # remove the username from the session if it&apos;s there</div><div class="line">    session.pop(&apos;username&apos;, None)</div><div class="line">    return redirect(url_for(&apos;index&apos;))</div><div class="line"></div><div class="line"># set the secret key.  keep this really secret:</div><div class="line">app.secret_key = &apos;A0Zr98j/3yX R~XHH!jmN]LWX/,?RT&apos;</div></pre></td></tr></table></figure></p>
<p>这里提到的 escape() 可以在你模板引擎外做转义（如同本例）。</p>
<p>如何生成强壮的密钥<br>随机的问题在于很难判断什么是真随机。一个密钥应该足够随机。你的操作系统可以基于一个密钥随机生成器来生成漂亮的随机值，这个值可以用来做密钥:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import os</div><div class="line">&gt;&gt;&gt; os.urandom(24)</div><div class="line">&apos;\xfd&#123;H\xe5&lt;\x95\xf9\xe3\x96.5\xd1\x01O&lt;!\xd5\xa2\xa0\x9fR&quot;\xa1\xa8&apos;</div></pre></td></tr></table></figure></p>
<p>把这个值复制粘贴进你的代码中，你就有了密钥。<br>使用基于 cookie 的会话需注意: Flask 会将你放进会话对象的值序列化至 Cookies。如果你发现某些值在请求之间并没有持久存在，然而确实已经启用了 Cookies，但也没有得到明确的错误信息。这时，请检查你的页面响应中的 Cookies 的大小，并与 Web 浏览器所支持的大小对比。</p>
<p>消息闪现<br>反馈，是良好的应用和用户界面的重要构成。如果用户得不到足够的反馈，他们很可能开始厌恶这个应用。 Flask 提供了消息闪现系统，可以简单地给用户反馈。 消息闪现系统通常会在请求结束时记录信息，并在下一个（且仅在下一个）请求中访问记录的信息。展现这些消息通常结合要模板布局。</p>
<p>使用 flash() 方法可以闪现一条消息。要操作消息本身，请使用 get_flashed_messages() 函数，并且在模板中也可以使用。完整的例子见 消息闪现 部分。</p>
<p>#日志记录<br>0.3 新版功能.</p>
<p>有时候你会处于这样一种境地，你处理的数据本应该是正确的，但实际上不是。 比如，你会有一些向服务器发送请求的客户端代码，但请求显然是畸形的。这可能是用户篡改了数据，或是客户端代码的粗制滥造。大多数情况下，正常地返回 400 Bad Request 就可以了，但是有时候不能这么做，并且要让代码继续运行。</p>
<p>你可能依然想要记录下，是什么不对劲。这时日志记录就派上了用场。从 Flask 0.3 开始，Flask 就已经预置了日志系统。</p>
<p>这里有一些调用日志记录的例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">app.logger.debug(&apos;A value for debugging&apos;)</div><div class="line">app.logger.warning(&apos;A warning occurred (%d apples)&apos;, 42)</div><div class="line">app.logger.error(&apos;An error occurred&apos;)</div></pre></td></tr></table></figure></p>
<p>附带的 logger 是一个标准日志类 Logger ，所以更多信息请查阅 logging 的文档 。</p>
<p>整合 WSGI 中间件<br>如果你想给你的应用添加 WSGI 中间件，你可以封装内部 WSGI 应用。例如若是你想用 Werkzeug 包中的某个中间件来应付 lighttpd 中的 bugs ，可以这样做:</p>
<p>from werkzeug.contrib.fixers import LighttpdCGIRootFix<br>app.wsgi_app = LighttpdCGIRootFix(app.wsgi_app)<br>部署到 Web 服务器¶<br>准备好部署你的 Flask 应用了？你可以立即部署到托管平台来圆满完成快速入门，以下厂商均向小项目提供免费的方案:</p>
<p>在 Heroku 上部署 Flask<br>在 dotCloud 上部署 Flask 附 Flask 的具体说明<br>托管 Flask 应用的其它选择:</p>

  </article>
  <div class="random-toc-area">
  <button class="btn-hide-toc btn-hide-toc-show" style="display: none" onclick="TOCToggle()">显示目录</button>
  <button class="btn-hide-toc btn-hide-toc-hide" onclick="TOCToggle()">隐藏目录</button>
  <div class="random-toc">
    <h2>目录</h2>
    
  </div>
</div>

  
<nav id="pagination">
  
    <a href="/2017/03/07/flask入门(1)/" class="prev">&larr; 上一篇 初识flask（一）</a>
  

  

  
    <a href="/2017/03/07/flask学习（二）/" class="next">下一篇 flask学习（二） &rarr;</a>
  
</nav>

  <!-- JiaThis Button BEGIN -->

<!-- JiaThis Button END -->


      
      <div class="ds-thread" data-thread-key="2017/03/07/flask学习（4）/" data-title="flask学习（四--第一个小应用）" data-url="https://aiwanxia.github.io/2017/03/07/flask学习（4）/"></div>
      
      
      
    </div>
  </div>

  <div id="bottom-outer">
    <div id="bottom-inner">
      Site by satan using
      <a href="http://hexo.io">Hexo</a> & <a href="https://github.com/stiekel/hexo-theme-random">Random</a>
      <br>
      
    </div>
  </div>
</div>

</div>

  <script type="text/javascript">
var duoshuoQuery = {short_name:"aiwanxia"};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
   || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>



<div id="user-card">
  <div class="center-field">
    <img class="avatar" src="http://photo.yupoo.com/lujunyuan/BLsD9Vlx/medish.jpg">
    <p id="description">always be shiny!</p>
    <ul class="social-icon">
  
  
    <li>
      <a href="https://github.com/aiwanxia/aiwanxia.github.io">
        
          <i class="icon iconfont github">&#xe606;</i>
        
      </a>
    </li>
  
    <li>
      <a href="https://www.zhihu.com/people/satan.i4.com/activities">
        
          <i class="icon iconfont zhihu">&#xe60b;</i>
        
      </a>
    </li>
  
</ul>
  </div>
</div>


<div id="btn-view">Hide</div>

<script>
// is trigger analytics / tongji script
var isIgnoreHost = false;

if(window && window.location && window.location.host) {
  isIgnoreHost = ["localhost","127.0.0.1"].some(function(address){
    return 0 === window.location.host.indexOf(address);
  });
}

var isTriggerAnalytics = !( true && isIgnoreHost );

</script>




  
  
    <script src="/js/jquery-2.2.3.min.js"></script>
  
    <script src="/js/vegas.min.js"></script>
  
    <script src="/js/random.js"></script>
  
    <script src="/js/highlight.pack.js"></script>
  
    <script src="/js/jquery.mousewheel.pack.js"></script>
  
    <script src="/js/jquery.fancybox.pack.js"></script>
  
    <script src="/js/jquery.fancybox-thumbs.js"></script>
  
    <script src="/js/plyr.js"></script>
  

<script>

  // fancybox
  var backgroundImages = [];
  
  $('#post').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox') || $(this).parent().hasClass('fancybox-thumb')) return;
      var alt = this.alt || this.title;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'post' + i);
    });
  });
  $(".fancybox").fancybox();

var vegasConfig = {"preload­Image":true,"transition":["slideLeft2","slideRight2","flash2"],"timer":true,"delay":5000,"shuffle":true,"count":28};
var unsplashConfig = {"gravity":"north"};
// is show background images
var turnoffBackgroundImage = false;



  turnoffBackgroundImage = true;


var backgroundColor = "34495E";

$(".fancybox-thumb").fancybox({
  prevEffect: 'none',
  nextEffect: 'none',
  helpers: {
    title: {
      type: 'outside'
    },
    thumbs: {
      width: 50,
      height: 50
    }
  }
});

// show video with plyr
$(".video-container iframe").each(function(i){
  var url = $(this).attr('src');
  var id = url.split('/').pop();
  var plyrContainer = document.createElement('div');
  plyrContainer.className = 'plyr';
  var plyrElement = document.createElement('div');
  plyrElement.dataset.videoId = id;
  switch(true) {
    case url.search('youtube.com') >= 0:
      plyrElement.dataset.type = 'youtube';
      break;
    case url.search('vimeo.com') >= 0:
      plyrElement.dataset.type = 'vimeo';
      break;
    default:
      return;
  };
  plyrContainer.appendChild(plyrElement);
  $(this).parent().html(plyrContainer);
});
plyr.setup('.plyr', {iconUrl: '/css/sprite.svg'});
</script>
</body>
</html>

